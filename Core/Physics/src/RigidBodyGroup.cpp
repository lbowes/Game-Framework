#include "RigidBodyGroup.h"

RigidBodyGroup::RigidBodyGroup(Integrator integrator, SubUpdateDepth subUpdateDepth) :
	RigidBody(integrator),
	mSubUpdateDepth(subUpdateDepth)
{ }

void RigidBodyGroup::addBody(RigidBody& sub, GF::CoordTransform3D subToComposite) {
	bool reusedSlot = false;
	
	//Before adding anything else to the vector we want to check whether or not a space has been vacated by a previous now-disconnected body
	for (int i = 0; i < mSubBodies.size(); i++) {
		if (mSubBodies[i].mConnected == false) {
			mSubBodies[i] = SubBody(sub, subToComposite);
			updateSubState(mSubBodies[i]);
			reusedSlot = true;
			break;
		}
	}
	
	//But if we've not been able to find a spare space, then create a new one
	if (!reusedSlot) {
		mSubBodies.push_back(SubBody(sub, subToComposite));
		updateSubState(mSubBodies.back());
	}

	updateCombinedMass_local();
	updateCombinedInertia_local();
}

void RigidBodyGroup::update(double t, double dt) {
	//If there is one body connected to the group, it must be classed as disconnected (there is no group anymore)
	if (isFullyFragmentated()) {
		for (SubBody& sub : mSubBodies)
			sub.disconnect();
	}
	else {
		//Use the result of the integration to manually provide the state of each of the connected subs (re-position, re-orient etc)
		updateAllSubStates();
		
		//Update the combined properties of the group
		updateCombinedMass_local();
		updateCombinedInertia_local();

		//Integrate the group state
		integrate(t, dt);
	}
}

void RigidBodyGroup::updateCombinedMass_local() {
	Mass combined;

	for (SubBody& sub : mSubBodies) {
		if (sub.mConnected) {
			const Mass& subMass_sub = sub.mRigidBody->immutableState().getMass_local();
			glm::dvec3 subCentreMass_group = sub.mSubToComposite.toParentSpace(subMass_sub.getCentre());
			combined += Mass(subMass_sub.getValue(), subCentreMass_group);
		}
	}

	mState.setMass_local(combined);
}

void RigidBodyGroup::updateCombinedInertia_local() {
	//Use the relative transformations of the sub bodies to calculate a group inertia tensor
	//1. Rotate the inertia tensor of each sub into group space
	//2. Use the parallel axis theorem to translate the new inertia from the sub's centre of mass, to the group's centre of mass
	//3. Add this to the total

	InertiaTensor combinedInertia;

	for (SubBody& sub : mSubBodies) {
		if (sub.mConnected) {
			const State& subState = sub.mRigidBody->immutableState();
			InertiaTensor rotatedSub = subState.getInertiaTensor_local().afterRotation(sub.mSubToComposite.getLocalToParent_rotation());
			combinedInertia += InertiaTensor::parallelAxis(
				rotatedSub,
				subState.getMass_local().getValue(),
				mState.getMass_local().getCentre() - sub.mSubToComposite.toParentSpace(subState.getMass_local().getCentre())
			);
		}
	}

	mState.setInertiaTensor_local(combinedInertia);
}

void RigidBodyGroup::addForces(const State& state, double t) 
	//Adds all the forces generated by subs to the total, for use by the group.
{
	for (SubBody& sub : mSubBodies) {
		if (sub.mConnected) {
			for (const Force_world& force_world : sub.mRigidBody->getForces_world())
				addForce({ force_world.mForce_world, sub.mSubToComposite.toParentSpace(force_world.mApplicationPoint_local) });
		}
	}
}

void RigidBodyGroup::addTorques(const State& state, double t) { 
	//addTorque_world({ 0.0, 0.0, 480.0 });
}

void RigidBodyGroup::updateAllSubStates() 
	//This function must be called to update the sub bodies when the composite body's state has changed.
{
	for (SubBody& sub : mSubBodies) {
		if (sub.mConnected)
			updateSubState(sub);
	}
}

void RigidBodyGroup::updateSubState(SubBody& toUpdate) {
	using namespace glm;

	State& subState = toUpdate.mRigidBody->mutableState();

	//Regardless of update depth, all sub bodies must be given a position_world and orientation_world each update
	//Position
	subState.setPosition_world(
		mState.getObjectSpace().toParentSpace(
			toUpdate.mSubToComposite.toParentSpace()
		)
	);

	//Orientation
	subState.setOrientation_world(
		mState.getObjectSpace().toParentSpace_rotation(
			glm::toQuat(toUpdate.mSubToComposite.getLocalToParent_rotation())
		)
	);

	//If we're only performing a shallow update, then the sub bodies won't be given their full state until they disconnect,
	if (mSubUpdateDepth == SubUpdateDepth::shallow) {
		subState.setVelocity_world(glm::dvec3(0.0));
		subState.setAngularVelocity_world(glm::dvec3(0.0));
	}
	//but if this is a deep update, then the entire state of the sub bodies must be calculated each update.
	else if (mSubUpdateDepth == SubUpdateDepth::deep) {
		//Linear velocity
		subState.setVelocity_world(
			mState.velocityAtLocalPoint_world(
				toUpdate.mSubToComposite.toParentSpace(
					subState.getMass_local().getCentre()
				)
			)
		);

		//Angular velocity
		subState.setAngularVelocity_world(mState.getAngularVelocity_world());
	}
}

bool RigidBodyGroup::isFullyFragmentated() {
	unsigned mNumConnections = 0;

	for (SubBody& sub : mSubBodies)
		mNumConnections += sub.mConnected;

	return mNumConnections < 2;
}